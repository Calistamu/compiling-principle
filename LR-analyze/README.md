# python实现LR(0)语法分析

## 代码思路分析

### 构造LR(0)项目集：
* 构造I的闭包CLOSURE(I)的算法如下：  
I的任何项目都属于CLOSURE(I)；  
若A→α•Bβ属于CLOSURE(I)，对任何产生式B→γ，B→•γ也属于CLOSURE(I)；  
重复执行上述两步骤直至CLOSURE(I)不再增大为止。  
>get_CLOSURE()
* Go(I,a)函数构造算法
I为当前状态，X为文法符号，J为I中所有形如A->α·Xβ的项目的后续项目所组成的集合，而CLOSURE(J)就是项目集I关于X的后续状态  
>go()
* 判别LR项目集是否合法：  
无移进项目和规约项目并存  
无多个规约项目并存  
>lr_is_legal()
### 构造LR(0)分析表
1. 假定项目集规范族C={I0,I1,…,In}。令每一个项目集Ik的下标k作为分析器的状态。分析表的ACTION子表和GOTO子表可按如下方法构造
2. 令那个包含项目S’→•S的集合Ik的下标k为分析器的初态。
3. 若项目A→α•aβ属于Ik且GO(Ik , a)= Ij,a为终结符，置ACTION[k,a]为“把(j,a)移进栈”，简记为“sj”。
4. 若项目A→α•属于Ik，对任何终结符a(或结束符#)，置ACTION[k,a]为“用产生式A→α进行归约”，简记为“rj”（假定产生式A→α是文法G’的第j个产生式）。
5. 若项目S’→S•属于Ik，则置ACTION[k,#]为“接受”，简记为“acc”。
6. 若GO(Ik , A)= Ij，A为非终结符，则置GOTO[k,A]=j。
7. 分析表中凡不能用规则1至4填入信息的空白格均填上“err”。
>get_lr_table()
### LR0规约
1. 遍历输入字符串，对于每一个字符，获取当前状态栈的顶部的状态值，通过查询action表获取的当前的操作是移进、规约还是接受
2. 如果当前操作是移进，将新的状态放入状态栈当中，当移入的字符放入符号栈中。
3. 如果当前操作是规约，那么将需要规约的部分的状态从状态栈中弹出，将规约后的状态放入状态栈，将规约后的左部放入符号栈，当前的字符不向下推进
4. 如果接收，则结束
>stipulation()
